{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Synthetic Data Engine \ud83d\udc8e","text":"<p>Documentation | Technical Paper | Free Cloud Service</p> <p>Create high-fidelity privacy-safe synthetic data:</p> <ol> <li>train a generative model once:<ul> <li>train on flat or sequential data</li> <li>control training time &amp; params</li> <li>monitor training progress</li> <li>optionally enable differential privacy</li> <li>optionally provide context data</li> </ul> </li> <li>generate synthetic data samples to your needs:<ul> <li>up-sample / down-sample</li> <li>conditionally generate</li> <li>rebalance categories</li> <li>impute missing values</li> <li>incorporate fairness</li> <li>adjust sampling temperature</li> <li>predict / classify / regress</li> <li>detect outliers / anomalies</li> <li>and more</li> </ul> </li> </ol> <p>...all within your own compute environment, all with a few lines of Python code \ud83d\udca5.</p> <p>Note: Models only need to be trained once and can then be flexibly reused for various downstream tasks \u2014 such as regression, classification, imputation, or sampling \u2014 without the need for retraining.</p> <p>Two model classes with these methods are available:</p> <ol> <li><code>TabularARGN()</code>: For structured, flat or sequential tabular data.</li> <li><code>argn.fit(data)</code>: Train a TabularARGN model</li> <li><code>argn.sample(n_samples)</code>: Generate samples</li> <li><code>argn.predict(target, n_draws, agg_fn)</code>: Predict a feature</li> <li><code>argn.predict_proba(target)</code>: Estimate probabilities</li> <li><code>argn.log_prob(data)</code>: Compute log likelihood</li> <li><code>argn.impute(data)</code>: Fill missing values</li> <li><code>LanguageModel()</code>: For semi-structured, flat textual tabular data.</li> <li><code>.fit(data)</code>: Train a Language model</li> <li><code>.sample(n_samples)</code>: Generate samples</li> </ol> <p>This library serves as the core model engine for the Synthetic Data SDK. For an easy-to-use, higher-level toolkit, please refer to the SDK.</p>"},{"location":"#installation","title":"Installation","text":"<p>It is highly recommended to install the package within a dedicated virtual environment using uv.</p> <p>The latest release of <code>mostlyai-engine</code> can be installed via uv:</p> <pre><code>uv pip install -U mostlyai-engine\n</code></pre> <p>or alternatively for a GPU setup (needed for LLM finetuning and inference): <pre><code>uv pip install -U 'mostlyai-engine[gpu]'\n</code></pre></p> <p>On Linux, one can explicitly install the CPU-only variant of torch together with <code>mostlyai-engine</code>:</p> <pre><code>uv pip install -U torch==2.9.1+cpu torchvision==0.24.1+cpu mostlyai-engine --extra-index-url https://download.pytorch.org/whl/cpu\n</code></pre>"},{"location":"#tabularargn-for-flat-data","title":"TabularARGN for Flat Data","text":"<p>The <code>TabularARGN</code> class provides a scikit-learn-compatible interface for working with structured tabular data. It can be used for synthetic data generation, classification, regression, and imputation.</p>"},{"location":"#model-training","title":"Model Training","text":"<p>Load your data and train the model:</p> <pre><code>import pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom mostlyai.engine import TabularARGN\n\n# prepare data\ndata = pd.read_csv(\"https://github.com/user-attachments/files/23480587/census10k.csv.gz\")\ndata_train, data_test = train_test_split(data, test_size=0.2)\n\n# fit TabularARGN\nargn = TabularARGN()\nargn.fit(data_train)\n</code></pre>"},{"location":"#sampling-synthetic-data-generation","title":"Sampling / Synthetic Data Generation","text":"<p>Generate new synthetic samples:</p> <pre><code># unconditional sampling\nargn.sample(n_samples=1000)\n</code></pre> <p>Generate new synthetic samples conditionally:</p> <pre><code># prepare seed\nseed_data = pd.DataFrame({\n    \"age\": [25, 50],\n    \"education\": [\"Bachelors\", \"HS-grad\"]\n})\n\n# conditional sampling\nargn.sample(seed_data=seed_data)\n</code></pre>"},{"location":"#imputation-filling-gaps","title":"Imputation / Filling Gaps","text":"<p>Fill in missing values:</p> <pre><code># prepare demo data with missings\ndata_with_missings = data_test.head(300).reset_index(drop=True)\ndata_with_missings.loc[0:299, \"age\"] = pd.NA\ndata_with_missings.loc[0:199, \"race\"] = pd.NA\ndata_with_missings.loc[100:299, \"income\"] = pd.NA\n\n# impute missing values each with a random sample\ndata_imputed = argn.impute(data_with_missings)\n\n# impute missing values each with their point estimates\ndata_imputed = argn.impute(data_with_missings, n_draws=100)\n</code></pre>"},{"location":"#predictions-classification","title":"Predictions / Classification","text":"<p>Predict any categorical target column:</p> <pre><code>from sklearn.metrics import accuracy_score, roc_auc_score\n\n# predict class labels for a categorical\npredictions = argn.predict(data_test, target=\"income\", n_draws=100, agg_fn=\"mode\")\n\n# evaluate performance\naccuracy = accuracy_score(data_test[\"income\"], predictions)\nauc = roc_auc_score(data_test[\"income\"], probabilities[:, 1])\nprint(f\"Accuracy: {accuracy:.3f}, AUC: {auc:.3f}\")\n</code></pre>"},{"location":"#predictions-regression","title":"Predictions / Regression","text":"<p>Predict any numerical target column:</p> <pre><code>from sklearn.metrics import mean_absolute_error\n\n# predict target values\npredictions = argn.predict(data_test, target=\"age\", n_draws=10, agg_fn=\"mean\")\n\n# evaluate performance\nmae = mean_absolute_error(data_test[\"age\"], predictions)\nprint(f\"MAE: {mae:.1f} years\")\n</code></pre>"},{"location":"#conditional-probabilities","title":"Conditional Probabilities","text":"<p>Assess any marginal conditional probability, for one or more target columns:</p> <pre><code># extract class probabilities for a categorical\nargn.predict_proba(\n    X=pd.DataFrame({\n        \"age\": [25, 30, 35],\n        \"sex\": [\"Male\", \"Female\", \"Male\"],\n    }),\n    target=\"income\"\n)\n\n# extract bin probabilities for a numerical\nargn.predict_proba(\n    X=pd.DataFrame({\n        # \"age\": [25, 30, 35],\n        \"sex\": [\"Male\", \"Female\", \"Male\"],\n        \"occupation\": [\"Craft-repair\", \"Craft-repair\", \"Craft-repair\"]\n    }),\n    target=\"capital_gain\"\n)\n\n# extract two-way marginals\nargn.predict_proba(\n    X=data_test[[\"age\", \"race\"]],\n    target=[\"sex\", \"income\"]\n)\n</code></pre>"},{"location":"#log-probability","title":"Log Probability","text":"<p>Compute log likelihood of observations:</p> <pre><code># compute log probability for each observation\nlog_probs = argn.log_prob(data_test)\n\n# list top 10 outliers\ndata_test.iloc[log_probs.argsort()[:10]]\n</code></pre>"},{"location":"#tabularargn-for-sequential-data","title":"TabularARGN for Sequential Data","text":"<p>For sequential data (e.g., time series or event logs), specify the context key:</p>"},{"location":"#model-training-with-context-data","title":"Model Training - With Context Data","text":"<pre><code>import pandas as pd\nfrom mostlyai.engine import TabularARGN\n\n# load sequential data\ntgt_data = pd.read_csv(\"https://github.com/user-attachments/files/23480787/batting.csv.gz\")\nctx_data = pd.read_csv(\"https://github.com/user-attachments/files/23480786/players.csv.gz\")\n\n# fit TabularARGN with a context key column\nargn = TabularARGN(\n    tgt_context_key=\"players_id\",\n    ctx_primary_key=\"id\",\n    ctx_data=ctx_data,\n    max_training_time=2,  # 2 minutes\n    verbose=0,\n)\nargn.fit(tgt_data)\n</code></pre>"},{"location":"#sampling-synthetic-data-generation_1","title":"Sampling / Synthetic Data Generation","text":"<p>Generate new synthetic samples (using existing context): <pre><code>argn.sample(n_samples=5)\n</code></pre></p> <p>Generate new synthetic samples conditionally (using custom context and seed):</p> <pre><code>ctx_data = pd.DataFrame({\n    \"id\": [\"Player1\", \"Player2\"],\n    \"weight\": [170, 160],\n    \"height\": [70, 68],\n    \"bats\": [\"R\", \"L\"],\n    \"throws\": [\"R\", \"L\"],\n})\nargn.sample(ctx_data=ctx_data)\n</code></pre>"},{"location":"#basic-usage-of-languagemodel","title":"Basic Usage of LanguageModel","text":"<p>The <code>LanguageModel</code> class provides a scikit-learn-compatible interface for working with semi-structured textual data. It leverages pre-trained language models or trains lightweight LSTM models from scratch to generate synthetic text data.</p> <p>Note: The default model is <code>MOSTLY_AI/LSTMFromScratch-3m</code>, a lightweight LSTM model trained from scratch (GPU strongly recommended). You can also use pre-trained HuggingFace models by setting model to e.g. <code>microsoft/phi-1.5</code> (GPU required).</p>"},{"location":"#model-training_1","title":"Model Training","text":"<p>Load your data and train the model:</p> <pre><code>import pandas as pd\nfrom mostlyai.engine import LanguageModel\n\n# load data\ndata = pd.read_csv(\"https://github.com/user-attachments/files/23486562/airbnb20k.csv.gz\")\n\n# fit LanguageModel\nlm = LanguageModel(\n    model=\"MOSTLY_AI/LSTMFromScratch-3m\",\n    tgt_encoding_types={\n        'neighbourhood': 'LANGUAGE_CATEGORICAL',\n        'title': 'LANGUAGE_TEXT',\n    },\n    max_training_time=10,  # 10 minutes\n    verbose=1,\n)\nlm.fit(data)\n</code></pre>"},{"location":"#sampling-synthetic-text-generation","title":"Sampling / Synthetic Text Generation","text":"<p>Generate new synthetic samples using the trained language model:</p> <pre><code># unconditional sampling\nlm.sample(\n    n_samples=100,\n    sampling_temperature=0.8,\n)\n</code></pre> <pre><code># prepare seed\nseed_data = pd.DataFrame({\n    \"neighbourhood\": [\"Westminster\", \"Hackney\"],\n})\n\n# conditional sampling with seed values\nlm.sample(\n    seed_data=seed_data,\n    sampling_temperature=0.8,\n)\n</code></pre>"},{"location":"#further-examples","title":"Further Examples","text":"<p>Example notebooks demonstrating various use cases are available in the <code>examples</code> directory: - TabularARGN for flat tabular data  - TabularARGN for sequential data  - LanguageModel for textual data </p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#engine-reference","title":"Engine Reference","text":""},{"location":"api/#mostlyai.engine.split","title":"mostlyai.engine.split","text":"<pre><code>split(\n    tgt_data,\n    *,\n    ctx_data=None,\n    tgt_primary_key=None,\n    ctx_primary_key=None,\n    tgt_context_key=None,\n    model_type=None,\n    tgt_encoding_types=None,\n    ctx_encoding_types=None,\n    n_partitions=1,\n    trn_val_split=0.8,\n    workspace_dir=\"engine-ws\",\n    update_progress=None\n)\n</code></pre> <p>Splits the provided original data into training and validation sets, and stores these as partitioned Parquet files. This is a simplified version of <code>mostlyai-data</code>, tailored towards single- and two-table use cases, while requiring all data to be passed as DataFrames in memory.</p> <p>Creates the following folder structure within the <code>workspace_dir</code>:</p> <ul> <li><code>OriginalData/tgt-data</code>: Partitioned target data files.</li> <li><code>OriginalData/tgt-meta</code>: Metadata files for target data.</li> <li><code>OriginalData/ctx-data</code>: Partitioned context data files (if context is provided).</li> <li><code>OriginalData/ctx-meta</code>: Metadata files for context data (if context is provided).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tgt_data</code> <code>DataFrame</code> <p>DataFrame containing the target data.</p> required <code>ctx_data</code> <code>DataFrame | None</code> <p>DataFrame containing the context data.</p> <code>None</code> <code>tgt_primary_key</code> <code>str | None</code> <p>Primary key column name in the target data.</p> <code>None</code> <code>ctx_primary_key</code> <code>str | None</code> <p>Primary key column name in the context data.</p> <code>None</code> <code>tgt_context_key</code> <code>str | None</code> <p>Context key column name in the target data.</p> <code>None</code> <code>model_type</code> <code>str | ModelType | None</code> <p>Model type for the target data. If not provided, it will be inferred from the encoding types, or set to TABULAR by default.</p> <code>None</code> <code>tgt_encoding_types</code> <code>dict[str, str | ModelEncodingType] | None</code> <p>Encoding types for columns in the target data (excluding key columns).</p> <code>None</code> <code>ctx_encoding_types</code> <code>dict[str, str | ModelEncodingType] | None</code> <p>Encoding types for columns in the context data (excluding key columns).</p> <code>None</code> <code>n_partitions</code> <code>int</code> <p>Number of partitions to split the data into.</p> <code>1</code> <code>trn_val_split</code> <code>float | Callable[[Series], tuple[Series, Series]]</code> <p>Fraction of data to use for training (0 &lt; value &lt; 1), or a callable that takes keys as input and returns (trn_keys, val_keys) tuple.</p> <code>0.8</code> <code>workspace_dir</code> <code>str | Path</code> <p>Path to the workspace directory where files will be created.</p> <code>'engine-ws'</code> <code>update_progress</code> <code>ProgressCallback | None</code> <p>A custom progress callback.</p> <code>None</code>"},{"location":"api/#mostlyai.engine.analyze","title":"mostlyai.engine.analyze","text":"<pre><code>analyze(\n    *,\n    value_protection=True,\n    differential_privacy=None,\n    workspace_dir=\"engine-ws\",\n    update_progress=None\n)\n</code></pre> <p>Generates (privacy-safe) column-level statistics of the original data, that has been <code>split</code> into the workspace. This information is required for encoding the original as well as for decoding the generating data.</p> <p>Creates the following folder structure within the <code>workspace_dir</code>:</p> <ul> <li><code>ModelStore/tgt-stats/stats.json</code>: Column-level statistics for target data</li> <li><code>ModelStore/ctx-stats/stats.json</code>: Column-level statistics for context data (if context is provided).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value_protection</code> <code>bool</code> <p>Whether to enable value protection for rare values.</p> <code>True</code> <code>workspace_dir</code> <code>str | Path</code> <p>Path to workspace directory containing partitioned data.</p> <code>'engine-ws'</code> <code>update_progress</code> <code>ProgressCallback | None</code> <p>Optional callback to update progress during analysis.</p> <code>None</code>"},{"location":"api/#mostlyai.engine.encode","title":"mostlyai.engine.encode","text":"<pre><code>encode(*, workspace_dir='engine-ws', update_progress=None)\n</code></pre> <p>Encodes data in the workspace that has already been split and analyzed.</p> <p>Creates the following folder structure within the <code>workspace_dir</code>:</p> <ul> <li><code>OriginalData/encoded-data</code>: Encoded data for training, stored as parquet files.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>workspace_dir</code> <code>str | Path</code> <p>Directory path for workspace.</p> <code>'engine-ws'</code> <code>update_progress</code> <code>ProgressCallback | None</code> <p>Callback for progress updates.</p> <code>None</code>"},{"location":"api/#mostlyai.engine.train","title":"mostlyai.engine.train","text":"<pre><code>train(\n    *,\n    model=None,\n    max_training_time=14400.0,\n    max_epochs=100.0,\n    batch_size=None,\n    gradient_accumulation_steps=None,\n    enable_flexible_generation=True,\n    max_sequence_window=None,\n    differential_privacy=None,\n    model_state_strategy=ModelStateStrategy.reset,\n    device=None,\n    workspace_dir=\"engine-ws\",\n    update_progress=None,\n    upload_model_data_callback=None\n)\n</code></pre> <p>Trains a model with optional early stopping and differential privacy.</p> <p>Creates the following folder structure within the <code>workspace_dir</code>:</p> <ul> <li><code>ModelStore</code>: Trained model checkpoints and logs.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str | None</code> <p>The identifier of the model to train. If tabular, defaults to MOSTLY_AI/Medium. If language, defaults to MOSTLY_AI/LSTMFromScratch-3m.</p> <code>None</code> <code>max_training_time</code> <code>float | None</code> <p>Maximum training time in minutes. If None, defaults to 10 days.</p> <code>14400.0</code> <code>max_epochs</code> <code>float | None</code> <p>Maximum number of training epochs. If None, defaults to 100 epochs.</p> <code>100.0</code> <code>batch_size</code> <code>int | None</code> <p>Per-device batch size for training and validation. If None, determined automatically.</p> <code>None</code> <code>gradient_accumulation_steps</code> <code>int | None</code> <p>Number of steps to accumulate gradients. If None, determined automatically.</p> <code>None</code> <code>enable_flexible_generation</code> <code>bool</code> <p>Whether to enable flexible order generation. Defaults to True.</p> <code>True</code> <code>max_sequence_window</code> <code>int | None</code> <p>Maximum sequence window for tabular sequential models. Only applicable for tabular models.</p> <code>None</code> <code>differential_privacy</code> <code>DifferentialPrivacyConfig | dict | None</code> <p>Configuration for differential privacy training. If None, DP is disabled.</p> <code>None</code> <code>model_state_strategy</code> <code>ModelStateStrategy</code> <p>Strategy for handling existing model state (reset/resume/reuse).</p> <code>reset</code> <code>device</code> <code>device | str | None</code> <p>Device to run training on ('cuda' or 'cpu'). Defaults to 'cuda' if available, else 'cpu'.</p> <code>None</code> <code>workspace_dir</code> <code>str | Path</code> <p>Directory path for workspace. Training outputs are stored in ModelStore subdirectory.</p> <code>'engine-ws'</code> <code>update_progress</code> <code>ProgressCallback | None</code> <p>Callback function to report training progress.</p> <code>None</code> <code>upload_model_data_callback</code> <code>Callable | None</code> <p>Callback function to upload model data during training.</p> <code>None</code>"},{"location":"api/#mostlyai.engine.generate","title":"mostlyai.engine.generate","text":"<pre><code>generate(\n    *,\n    ctx_data=None,\n    seed_data=None,\n    sample_size=None,\n    batch_size=None,\n    sampling_temperature=1.0,\n    sampling_top_p=1.0,\n    device=None,\n    rare_category_replacement_method=RareCategoryReplacementMethod.constant,\n    rebalancing=None,\n    imputation=None,\n    fairness=None,\n    workspace_dir=\"engine-ws\",\n    update_progress=None\n)\n</code></pre> <p>Generates synthetic data from a trained model.</p> <p>Creates the following folder structure within the <code>workspace_dir</code>:</p> <ul> <li><code>SyntheticData</code>: Generated synthetic data, stored as parquet files.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ctx_data</code> <code>DataFrame | None</code> <p>Context data to be used for generation.</p> <code>None</code> <code>seed_data</code> <code>DataFrame | None</code> <p>Seed data to condition generation on fixed target columns.</p> <code>None</code> <code>sample_size</code> <code>int | None</code> <p>Number of samples to generate. Defaults to number of original samples.</p> <code>None</code> <code>batch_size</code> <code>int | None</code> <p>Batch size for generation. If None, determined automatically.</p> <code>None</code> <code>sampling_temperature</code> <code>float</code> <p>Sampling temperature. Higher values increase randomness.</p> <code>1.0</code> <code>sampling_top_p</code> <code>float</code> <p>Nucleus sampling probability threshold.</p> <code>1.0</code> <code>device</code> <code>str | None</code> <p>Device to run generation on ('cuda' or 'cpu'). Defaults to 'cuda' if available, else 'cpu'.</p> <code>None</code> <code>rare_category_replacement_method</code> <code>RareCategoryReplacementMethod | str</code> <p>Method for handling rare categories. Only applicable for tabular models.</p> <code>constant</code> <code>rebalancing</code> <code>RebalancingConfig | dict | None</code> <p>Configuration for rebalancing column distributions. Only applicable for tabular models.</p> <code>None</code> <code>imputation</code> <code>ImputationConfig | dict | None</code> <p>List of columns to impute missing values. Only applicable for tabular models.</p> <code>None</code> <code>fairness</code> <code>FairnessConfig | dict | None</code> <p>Configuration for fairness constraints. Only applicable for tabular models.</p> <code>None</code> <code>workspace_dir</code> <code>str | Path</code> <p>Directory path for workspace.</p> <code>'engine-ws'</code> <code>update_progress</code> <code>ProgressCallback | None</code> <p>Callback for progress updates.</p> <code>None</code>"},{"location":"api/#schema-reference","title":"Schema Reference","text":""},{"location":"api/#mostlyai.engine.domain.DifferentialPrivacyConfig","title":"mostlyai.engine.domain.DifferentialPrivacyConfig","text":"<p>The differential privacy configuration for training the model. If not provided, then no differential privacy will be applied.</p> <p>Parameters:</p> Name Type Description Default <code>max_epsilon</code> <code>float | None</code> <p>Specifies the maximum allowable epsilon value. If the training process exceeds this threshold, it will be terminated early. Only model checkpoints with epsilon values below this limit will be retained. If not provided, the training will proceed without early termination based on epsilon constraints.</p> <code>10.0</code> <code>delta</code> <code>float</code> <p>The delta value for differential privacy. It is the probability of the privacy guarantee not holding. The smaller the delta, the more confident you can be that the privacy guarantee holds. This delta will be equally distributed between the analysis and the training phase.</p> <code>1e-05</code> <code>noise_multiplier</code> <code>float</code> <p>Determines how much noise while training the model with differential privacy. This is the ratio of the standard deviation of the Gaussian noise to the L2-sensitivity of the function to which the noise is added.</p> <code>1.5</code> <code>max_grad_norm</code> <code>float</code> <p>Determines the maximum impact of a single sample on updating the model weights during training with differential privacy. This is the maximum norm of the per-sample gradients.</p> <code>1.0</code> <code>value_protection_epsilon</code> <code>float | None</code> <p>The DP epsilon of the privacy budget for determining the value ranges, which are gathered prior to the model training during the analysis step. Only applicable if value protection is True. Privacy budget will be equally distributed between the columns. For categorical we calculate noisy histograms and use a noisy threshold. For numeric and datetime we calculate bounds based on noisy histograms.</p> <code>1.0</code>"},{"location":"api/#mostlyai.engine.domain.FairnessConfig","title":"mostlyai.engine.domain.FairnessConfig","text":"<p>Configure a fairness objective for the table.</p> <p>The generated synthetic data will maintain robust statistical parity between the target column and the specified sensitive columns. All these columns must be categorical.</p> <p>Parameters:</p> Name Type Description Default <code>target_column</code> <code>str</code> required <code>sensitive_columns</code> <code>list[str]</code> required"},{"location":"api/#mostlyai.engine.domain.ImputationConfig","title":"mostlyai.engine.domain.ImputationConfig","text":"<p>Configure imputation. Imputed columns will suppress the sampling of NULL values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[str]</code> <p>The names of the columns to be imputed.</p> required"},{"location":"api/#mostlyai.engine.domain.ModelEncodingType","title":"mostlyai.engine.domain.ModelEncodingType","text":"<p>The encoding type used for model training and data generation.</p> <ul> <li><code>AUTO</code>: Model chooses among available encoding types based on the column's data type.</li> <li><code>TABULAR_CATEGORICAL</code>: Model samples from existing (non-rare) categories.</li> <li><code>TABULAR_NUMERIC_AUTO</code>: Model chooses among 3 numeric encoding types based on the values.</li> <li><code>TABULAR_NUMERIC_DISCRETE</code>: Model samples from existing discrete numerical values.</li> <li><code>TABULAR_NUMERIC_BINNED</code>: Model samples from binned buckets, to then sample randomly within a bucket.</li> <li><code>TABULAR_NUMERIC_DIGIT</code>: Model samples each digit of a numerical value.</li> <li><code>TABULAR_CHARACTER</code>: Model samples each character of a string value.</li> <li><code>TABULAR_DATETIME</code>: Model samples each part of a datetime value.</li> <li><code>TABULAR_DATETIME_RELATIVE</code>: Model samples the relative difference between datetimes within a sequence.</li> <li><code>TABULAR_LAT_LONG</code>: Model samples a latitude-longitude column. The format is \"latitude,longitude\".</li> <li><code>LANGUAGE_TEXT</code>: Model will sample free text, using a LANGUAGE model.</li> <li><code>LANGUAGE_CATEGORICAL</code>: Model samples from existing (non-rare) categories, using a LANGUAGE model.</li> <li><code>LANGUAGE_NUMERIC</code>: Model samples from the valid numeric value range, using a LANGUAGE model.</li> <li><code>LANGUAGE_DATETIME</code>: Model samples from the valid datetime value range, using a LANGUAGE model.</li> </ul>"},{"location":"api/#mostlyai.engine.domain.ModelStateStrategy","title":"mostlyai.engine.domain.ModelStateStrategy","text":"<p>The strategy of how any existing model states and training progress are to be handled.</p> <ul> <li><code>RESET</code>: Start training from scratch. Overwrite any existing model states and training progress.</li> <li><code>REUSE</code>: Reuse any existing model states, but start progress from scratch. Used for fine-tuning existing models.</li> <li><code>RESUME</code>: Reuse any existing model states and progress. Used for continuing an aborted training.</li> </ul>"},{"location":"api/#mostlyai.engine.domain.ModelType","title":"mostlyai.engine.domain.ModelType","text":"<p>The type of model.</p> <ul> <li><code>TABULAR</code>: A generative AI model tailored towards tabular data, trained from scratch.</li> <li><code>LANGUAGE</code>: A generative AI model build upon a (pre-trained) language model.</li> </ul>"},{"location":"api/#mostlyai.engine.domain.RareCategoryReplacementMethod","title":"mostlyai.engine.domain.RareCategoryReplacementMethod","text":"<p>Specifies how rare categories will be sampled. Only applicable if value protection has been enabled.</p> <ul> <li><code>CONSTANT</code>: Replace rare categories by a constant <code>_RARE_</code> token.</li> <li><code>SAMPLE</code>: Replace rare categories by a sample from non-rare categories.</li> </ul>"},{"location":"api/#mostlyai.engine.domain.RebalancingConfig","title":"mostlyai.engine.domain.RebalancingConfig","text":"<p>Configure rebalancing.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of the column to be rebalanced.</p> required <code>probabilities</code> <code>dict[str, float]</code> <p>The target distribution of samples values. The keys are the categorical values, and the values are the probabilities.</p> required"}]}